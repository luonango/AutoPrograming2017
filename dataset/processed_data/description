通过用户的uid查找用户的passwd数据
通过用户的uid查找用户的passwd数据
通过用户的uid查找用户的passwd数据
通过passwd结构获取用户的username数据
获得每个进程能够创建的各种系统资源的限制使用量
获取、设置和修改硬限制和软限制
设置硬限制和软限制
获取和修改硬限制和软限制
获取和修改硬限制和软限制
从标准输入设备读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buf指针所指向的字符数组中
接收输入的整个字符串直到换行为止
输入一个字符串，最长80个字符，回车结束输入。将输入的字符串显示到屏幕上。
接收输入的整个字符串直到换行为止,并显示在屏幕上
返回与给定服务名和协议名对应的相关服务信息
通过服务器的名字而非端口号来认知该服务器
通过服务器的名字而非端口号来认知该服务器
将网络字节顺序的端口值转换成主机顺序
会依参数pathname建立特殊的FIFO文件
会依参数pathname建立特殊的FIFO文件
会依参数pathname建立特殊的FIFO文件
会依参数pathname建立特殊的FIFO文件
会依参数pathname建立特殊的FIFO文件
在系统中以唯一的文件名创建一个文件并打开，而且只有当前用户才能访问这个临时文件，并进行读、写操作。
在系统中以唯一的文件名创建一个文件并打开，而且只有当前用户才能访问这个临时文件，并进行读、写操作。
在系统中以唯一的文件名创建一个文件并打开，而且只有当前用户才能访问这个临时文件，并进行读、写操作。
在系统中以唯一的文件名创建一个文件并打开，而且只有当前用户才能访问这个临时文件，并进行读、写操作。
用来将time_t结构数据转换成从公元1970年1月1日0时0分0秒算起至今的时间所经过的秒数。
用来将time_t结构数据转换成从公元1970年1月1日0时0分1秒算起至今的时间所经过的秒数。
用来将time_t结构数据转换成从公元1970年1月1日0时0分2秒算起至今的时间所经过的秒数。
用来将time_t结构数据转换成从公元1970年1月1日0时0分3秒算起至今的时间所经过的秒数。
用来将time_t结构数据转换成从公元1970年1月1日0时0分4秒算起至今的时间所经过的秒数。
返回对应于给定端口号和协议名的相关服务信息
返回对应于给定端口号和协议名的相关服务信息
查询给定端口的协议
名字与地址转换，根据给定端口号和可选协议查找相应的服务
根据服务名获取服务的信息
按顺序扫描服务数据库
输出服务数据库中的第一个服务，如果存在的话
输出服务数据库中的第二个服务，如果存在的话
输出服务数据库中的第三个服务，如果存在的话
输出服务数据库中的第四个服务，如果存在的话
返回调用进程的会话ID
通过系统调用创建一个与原来进程几乎完全相同的进程，返回调用进程的会话ID
根据进程名获得进程pid并获得会话ID
inetd服务器端代码
inetd客户端代码
tcp客户端
udp客户端
服务器端代码
用于获取进程实际用户ID并打印
首先获取进程的实际用户ID,然后根据ID获取用户名
设置时区,将参数time 所指的time_t 结构中的信息转换成真实世界所使用的时间日期表示方法。
获取当天的年月日日期信息
获取当天是一周中的哪一天
获取此时的时分秒信息
打开一个伪终端设备,授权访问从属伪终端设备,清除设备的锁,获取pts名
首先执行系统命令ls,获得/dev/pts目录下文件详情,然后打开一个伪终端,授权访问,清除设备的锁,获取新打开的pts名,之后再次执行系统命令,查看/dev/pts目录下文件的变化
将无符号整型转换伪网络序列格式,主机序列格式
从标准输入读取格式化字符串,以C的宽字节存储到str,再从标准输入读取整型,以宽字节存入变量I,最后打印格式化字符串
将文件b.txt读入,以宽字节存入宽字符数组,再以宽字节形式打印
将宽字符串,格式化后存入宽字符数组,在以宽字节形式打印
尝试打开文件,文件不存在时,打印错误原因
尝试执行文件,没有权限执行该文件时,打印错误信息
把主机字节序“16”转换为16位网络字节序
把输入16位主机字节序转换为16位网络字节序，并输出原主机字节序和转化后的网络字节序
用户输入16位主机字节序，程序将其转换为16位网络字节序，并输出
定义了一个主机字节顺序值99，输出“translating”，输出转换后的网络字节顺序值
将long型主机字节序转换a为网络字节序b，将得到的网络字节序b用ntohs转为主机字节序c，将b用ntohl转化为主机字节序
将输入的ip地址（文本字符串格式）转换为网络字节序二进制格式输出，再反转换为文本字符串格式输出
将用户输入的ip地址转换为网络字节序，再反转回ip地址输出
用户输入ip地址，将其转换为网络字节序，输出
将一个ip地址（文本字符串格式）转为网络字节序二进制，若出错则打印fail to convert，并退出程序； 若成功打印地址的16进制形式；再将地址由二进制转为文本字符串格式（点分十进制），若出错则打印fail to convert，并退出程序； 若成功打印地址的文本字符串格式（点分十进制）
将ip地址222.0.13.9转换成网络字节序二进制地址，若出错，则打印 error，成功则输出
将一个ip地址（文本字符串格式）转为网络字节序二进制，若出错则打印fail to convert，并退出程序； 若成功打印地址的16进制形式；再将地址由二进制转为文本字符串格式（点分十进制），若出错则打印fail to convert，并退出程序； 若成功打印地址的文本字符串格式（点分十进制）
将输入的ip地址（文本字符串格式）转换为网络字节序二进制格式输出，再反转换为文本字符串格式输出
将一个网络字节序的二进制地址99转换成字符串格式的IP地址
将用户输入的ip地址转换为网络字节序，再反转回ip地址输出
把网络字节序二进制地址转换成ip地址，若出错，则打印sorry，fail，退出；成功则输出ip地址
为用户user初始化附属组ID，失败输出 initgroup fail，成功输出ok
通过initgroups()初始化组文件，使一个普通用户获得root组ID，从而可以读取需要root权限才能操作的文件
在程序运行过程中修改程序运行的权限
初始化附属组id，使一个普通用户获得root权限
为用户xiao初始化附属组ID，如果geteuid（）不等于0，则退出；失败输出 initgroup fail，成功输出ok
通过返回值确定设备是否可移除
控制网络设备接口访问
打开指定的设备，获取设备字符串信息，或指定的第n个字符串信息
调用cmd命令memset
打开并控制LED设备开关
取得stdout指定的文件流所使用的文件描述符,判断设备的类型
打开.c文件判断是否为终端设备
打开指定文件，判断该文件是否为终端设备，如果是，获取终端设备的名称
取得stdout指定的文件流所使用的文件描述符,判断是否为终端设备，如果为终端设备，获取它运行时的限制值
取得stdout指定的文件流所使用的文件描述符,判断是否为终端设备，如果为终端设备，尝试获取该设备的大小并输出该值
检查指定pid的线程是否在运行，并杀死这个进程；若返回0，则说明线程在运行，且被kill掉了，若返回-1，则线程已经被停止
在父进程中尝试杀死子进程
在父进程中再fork新进程，在新进程的父进程中杀死自身进程及父级进程
给pid所指的进程发送SIGABRT（中止一个程序）信号
发送SIGABRT信号给子进程，此信号引起接收进程异常终止，等待子进程返回终止信息
将符号链接名为/modules/pass1 的所有者改为，user ID为"jones"和group ID为"cnd"
将/etc/passwd 的所有者和组都设为root
打开指定文件，修改其用户ID和组ID为500，在已打开的文件pathname2上修改其用户ID为500，但不修改它的组ID
建立/etc/passwd 的硬连接为pass
建立/path/passwd的硬连接为pass
建立/path/pass/passwd的硬连接为pass
创建硬链接test2.txt，测试链接数
创建硬链接path2.txt，测试链接数
创建符号链接
读取符号链接
将整数转换为字符串
把字符串转换为整型数
从myfile.txt文件中最多读取99个字符
用lio_listio发起一系列请求
对文件进行异步读操作
完成大量IO操作
用aio_suspend阻塞异步IO
使用信号作为AIO请求的通知
将服务器端的listen函数backlog设置为2，用20个客户端与服务器建立连接，查看连接的建立情况
监听客户端，当有请求时与客户端建立连接
连接服务器，并接收服务器的信息
用socket监听指定的地址端口
用socket与客户端建立连接
获取时间，然后转换成当地时间并格式化输出
利用setjmp设置跳回点，然后通过子函数的longjmp跳转回去
当一个setjmp对应多个longjmp的时候，可以从setjmp的返回值判断是从哪个longjmp跳转回来的。在cmd_add中val为1调用longjmp，setjmp的返回值就为1
利用lseek并写文件来扩展文件大小
测试标准输入能否被设置偏移量
创建一个具有空洞的文件
从一个文件的开头或中间某位置打印一段字符串。输出为：$ ./testing  This is a test file  test file that will
这个例子打开sample.dat文件，如果成功，把文件指针移动到第8位，程序将会在新的指针位置开始读取文件到缓存中
获取文件长度
判断文件（文件夹）是否可读
判断文件（文件夹）是否可写
判断文件（文件夹）是否可执行
获取文件夹总大小
判断文件（文件夹）的最后访问时间
判断文件（文件夹）的最后修改时间
判断一个文件是否普通类型
判断一个文件是否目录文件
判断一个文件是否字符设备
判断一个文件是否块设备
判断一个文件是否管道文件
向系统申请分配指定size个字节的内存空间
size的大小为零，返回指向堆空间的指针
分配size个char大小的string字符串
动态分配二维数组的内存空间
分配size个自定义结构体大小的内存空间
先判断目录是否存在，不存在则创建
创建一个可以读写与执行的目录
按照给定的路径，创建相应的多级目录
按照给定的路径名，依次递归创建父目录与子目录
按照给定的路径，现创建目录，然后再删除
根据绝对路径创建可读写与执行的目录
按照文件描述符和相对路径创建文件夹
在当前工作目录下创建目录
按照绝对路径创建文件夹
利用进程的文件描述符来创建文件夹
创建名为template的临时工作目录
在进程当前的工作目录下创建临时的工作目录
返回创建的临时工作目录的名称
创建一个进程使用的临时工作目录
创建可以同步输入输出的临时工作目录
把文件内容映射到一段内存上，通过对内存的读取和修改，实现对文件的读取和修改
两个进程通过映射普通文件实现共享内存通信
程序创建文件所需页面的内存映射，然后输出所需的字节。
通过共享映射的方式修改文件
通过匿名映射实现父子间进程通信
用于对内存区域的访问设置读写权限
程序分配四页内存，设置第三页为只读
将最初映射的内存为只写改为不可写
当线程试图对已保护的内存进行篡改时，中断处理函数把调用栈等信息打印出来
用于对消息队列执行相应的cmd操作，用消息队列实现聊天程序
系统内核中为系统中的每一个消息队列保存一个此数据结构的实例
修改消息队列的存取模式
用于删除消息队列
线程通过消息队列发送消息
接收与本进程id匹配的消息，发送类型为4的消息
两进程通过消息队列收发消息，此程序用于发送消息
两进程通过消息队列收发消息，此程序用于接收消息
创建一个新的消息队列或打开一个已存在的消息队列
创建和打开消息队列，实现消息发送
查看套接字选项的当前值
查看套接字选项的当前值
查看套接字选项的当前值
查看套接字选项的当前值
查看套接字选项的当前值
通过shadow口令访问影子密码文件
获得访问影子密码文件的接口。第一次调用时会取得第一项组数据，之后每调用一次就会返回下一项数据，直到已无任何数据时返回NULL。
通过用户输入，获取访问shadow的口令
通过用户输入，获取访问shadow的口令
通过参数，获取访问shadow的口令，并验证正确性
通过参数，获取访问shadow的口令，并验证正确性
以距1970年1月1日00：00：00的秒数的方式将当前时间表示出来
通过获取两个时间点的值，计算它们之间的差，用以了解期间经过多少时间
通过获取两个时间点的值，计算它们之间的差，用以了解期间经过多少时间
循环创建线程，并用时间间隔控制线程的运行时间
以距1970年1月1日00：00：00的秒数的方式将当前时间表示出来
这段程序实现了从func函数中跳转到main函数中
这段程序打开一个日志并使用setlogmask和LOG_UPTO函数使得一些低优先级的日志记录不会被写入日志
这段程序打开一个数据库获取相关信息后关闭数据库
这段程序实现创建新进程后将父进程和子进程归到不同进程组中
这段程序通过非局部跳转实现了异常处理
这段程序是实现了从test函数跳转到main函数中
这段程序通过逻辑位操作，使用setlogmask屏蔽了单一日志级别的写入
这段程序使用了基本的setlogmask函数，允许单一日志级别的写入
这段程序设置当前进程为新进程组的组长
打开组文件（如若它尚未被打开）并反绕它
由超级用户调用以便为调用进程设置附属组ID表
将实际组ID、有效组ID以及保存的设置组ID设置为gid
函数sethostent会打开文件，如果文件已经被打开，那么将其回绕
通过一些鼠标服务程序来控制一个文本模式的鼠标
通过调用Video BIOS函数0，先从标准文本模式(模式3)切换到一个由命令行输入的模式号，然后再切换回来
以切换VESA模式，改进了前文中的例子
演示使用isalnum（）与不同的语言环境（OS特定）。
检查给定字符是否是字母字符，即大写字母
检查给定字符是否是字母字符，即小写字母
根据当前C语言环境检查给定字符是否为大写字符。 在默认的“C”区域设置中，isupper只为大写字母返回true
检查给定字符是否是数字
检查给定的字符是否为十六进制数字字符（0123456789abcdef ABCDEF）
确定s指向第一个字节的多字节字符的大小（以字节为单位）
将第一个字节指向的多字节字符转换为宽字符，如果pwc不为空，则将其写入* pwc。
将宽字符wc转换为多字节编码，并将其（包括任何移位序列）存储在由s指向的第一个元素的字符数组中。 不超过MB_CUR_MAX个字符被存储
将多字节字符串从src的第一个元素指向的数组转换为宽字符表示。 转换的字符存储在dst指向的数组的连续元素中。 不超过len宽的字符被写入目标数组。
将第一个元素由src指向的数组的宽字符序列转换为以初始移位状态开始的窄多字节表示形式。 转换的字符存储在dst指向的char数组的连续元素中。 不超过len个字节写入目标数组。
如果ps不是空指针，则mbsinit函数确定指向的mbstate_t对象是否描述初始转换状态。
将单字节字符（重新解释为无符号字符）扩大为其宽字符等效。
修改进程的用户id
改变堆栈的大小，更改软硬限制值大小。设置子线程的时间限制
顺序扫描数据库/etc/services并打印服务，端口等信息
主程序test.c和初始化程序init.c。主程序每隔一分钟向/tmp目录中的日志test.log报告运行状态。初始化程序中的init_daemon函数负责生成守护进程。②创建进程id,并设置进程组id
获得字符串长度
实现一个打开流和缓冲区的绑定
为进程设置有效的组ID
设置进程环境变量
设置有效的用户ID
动态分配内存
管道通信
为了验证setpriority函数对线程是否有效
读取“/etc/protocols”全部信息，并将其打印出来
将getpwent()的读写地址指回密码文件开头
读取组识别码，进行判断是否为0，然后进行不同的组识别码的设置
本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。
设置程序进程执行优先权
打开网络协议的数据文件，读取数据文件，关闭数据文件
getpwent()逐条查找，查找匹配就输出。输出完应该调用setpwent将文件的偏移量重置为文件的起始位置。结束的时候调用endpwent关闭文件。
读取文件 /etc/protocols
将getpwent()的读写地址指回密码文件开头
修改文件名称
修改目录名称
当修改目录名称时，不能把旧的目录名作为新目录名的前缀
newname和oldname必须同为目录或同为文件
当newname和oldname完全相同时，函数不做任何修改直接返回成功
以相对路径的形式修改文件或目录的名称
oldname为相对路径，newname为绝对路径时，newdir被忽略
newname和oldname都是绝对路径，函数效果和rename相同
重设读取目录的位置为开头位置
读取目录下的文件和目录，返回目录指针
复制文件内容，在显示文件f1后将文件流设置到文件的起始位置
读取文件留内容，将文件流设置到文件的起始位置
通过文件指针写入内容，并将文件流设置到文件的起始位置
首先通过文件指针写入内容，然后通过文件指针输出内容，最后将文件指针恢复到文件首
将文件流设置到文件的起始位置然后开始读取文件内容
对信号量数组semnum编号的信号量做P操作与V操作
通过信号量实现进程间通信
打开和创建一个信号量集
关闭信号量
销毁信号量
信号量实现父子线程的等待与通信
初始化一个新的信号量
对信号量数组semnum编号的信号量做P操作与V操作
进程等待
进程同步
获取子进程的终止信号，然后进行输出
等待特定进程
得到一字符串表示目前当地的时间日期
得到从1970年1月1日00时00分00秒至今的GMT时间经过的秒数
获取当天零点的时间
使用semop实现P、V操作
使用semop()自动等待信号量0的值变成0，然后给信号量0的值增加1
使用semop()让semb等待sema执行才能执行
打开命名信号量“/mysemaphore”，如果不存在则创建信号量并赋初值10，并设置仅有当前用户可以操作此信号量
使用sem_post和sem_wait配合来达到线程同步，最后释放信号量
该程序使用一个未命名的信号量，该程序需要两个命令行参数，第一个指定用于计时的秒值，时间到了产生一个SLGALRM信号，sem_post则增加正在等待的信号量，第二个参数制定等待的最大时长
一个线程创建另一个线程，并且等待该线程的完成
实现生产消费者模型
初始化一个未命名信号量并且释放一个信号量,通过输出查看信号量值
把wsc1的字符串复制到wsc2，将“copy successful”复制给wsc3，然后输出wsc1、wsc2、wsc3
从myfile.txt文件从逐个字符的读取内容，并且用变量n统计有多少个“$”字符
一个字符一个字符的输出一个多字节字符串
通过命令行参数为信息队列注册一个通知请求，而在一个线程中会读取这些信息。
遍历第一个命令行参数所表示的路径下的目录树，如果没有参数，则遍历当前目录。显示所有文件的各种信息，
产生一串伪随机序列
产生不同的随机数
获取信号量
sem_post的时候加入sem_getvalue进行判断
创建一个信号量
对信号量数组semnum编号的信号量做P操作
对信号量数组semnum编号的信号量做V操作
P操作函数
信号量V操作
信号灯
创建并初始化信号量
打开一个已存在的有名信号量
从流中执行格式化输入
使用参数列表发送格式化输出到流 stream 中如果成功，则返回写入的字符总数，否则返回一个负数。
格式化输出到stdout，如果成功，则返回写入的字符的总数，否则返回一个负数。
返回成功转换并分配; 的字段数返回值不包括已读取但未分配的字段。 返回值为 0 表示没有分配任何字段。
从指定的字符串中读取整数和小写字母。
从终端输入一个字符串，vsscanf()会将参数str 的字符串根据参数format 字符串来转换并格式化数据
如果信号量大于0，将信号量减1，然后继续执行。否则被阻塞等待信号量大于0.
向已经建立连接的socket发送信息
向未连接的socket发送消息。发送前要建立连接，如果连接失败，发送信息失败
通过指定socket发送消息到对方主机
通过指定socket发送消息到对方主机
通过指定socket发送消息到对方主机
通过指定socket发送消息到对方主机
通过指定socket发送消息到对方主机
通过指定socket发送消息到对方主机
删除空目录
删除空目录
删除空目录
删除空目录
删除空目录
分析输入字符串，并将字符序列转换成指定类型的变量
分析输入字符串，并将字符序列转换成指定类型的变量
分析输入字符串，并将字符序列转换成指定类型的变量
分析输入字符串，并将字符序列转换成指定类型的变量
分析输入字符串，并将字符序列转换成指定类型的变量
确定一个或多个套接口的状态
确定一个或多个套接口的状态
确定一个或多个套接口的状态
确定一个或多个套接口的状态
确定一个或多个套接口的状态
设置参数dir目录流当前的读取位置
设置参数dir目录流当前的读取位置
设置参数dir目录流当前的读取位置
设置参数dir目录流当前的读取位置
设置参数dir目录流当前的读取位置
测试nofile.txt是否存在，如果不存在则跳出程序
终止一个进程
使用sig_alrm和pause可以令进程终止和休眠一段时间
对比abort和exit函数的不同，abort直接执行进程终止，而exit则会退出进程，还是会执行子函数的内容
进程间通信，利用了信号量通信的方法，在执行删除操作时推出进程。
非阻塞socket在accept使用的一个例子。如果服务器调用accept，并且当前没有连接请求时，服务器会阻塞知道一个请求到来。
网络通信中，服务端中的通信等待程序
应用http协议的时候，实现的一个简单的http程序，包含一个服务器和一个客户端。
服务器应该使用非阻塞地 accept。开始不把 socket 加入 epoll，需要向 socket 写数据的时候，直接调用 write 或者 send 发送数据。如果返回 EAGAIN，把 socket 加入 epoll，在 epoll 的驱动下写数据，全部数据发送完毕后，再移出 epoll。
基于UDP协议实现socket通信
有时，进程也希望按其实际用户ID和实际组ID来测试器访问能力。例如，当一个进程使用设置用户ID或设置ID功能作为另一个用户运行时，就可能会有这种需要。即使一个进程可能已经通过设置用户ID以超级用户权限运行，它仍可能想验证其实际用户能否访问一个给定的文件。access函数是按实际用户ID和实际组ID进行访问权限测试的。
确定文件的访问权限
此函数用于检测某个指定路径的文件（第一个参数 pathname），是否符合第二个参数选项（F_OK(是否是存在的文件），R_OK(是否可读），W_OK（是否可以写入）,X_OK(是否可以运行）；当参数1满足参数2条件时候返回0，不满足返回-1；
使用第二个参数ct中的分隔符字符串，分割第一个参数s，ct参数的分隔符可以是任意字符，可以是单个字符的分隔符，也可以是字符串形式的分隔符如:"!,;'/"等，都可以作为分隔符。
faccessat函数与access函数在下面两种情况下是相同的；一种是pathname参数为绝对值路径，另一种是fd参数取值为AT_FDCWD而pathname为相对路径。否则，faccessat计算相对于打开目录的pathname。 flag参数可用于改变faccessat的行为，如果flag设置为AT_EACCESS，访问检查的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。
在发送异步请求时，当希望能够停止异步I/O，则调用aio_cancel
sigev_notify等于SIGEV_THREAD的情况，sigevent就是当信号到达时，指定特定的处理方式来处理该信号
在异步读取I/O当中进行异步取消
发起一系列的请求，然后出错进行异步取消
程序展示了如何使用等价的异步I/O函数做同样的任务。程序使用了8个缓冲区，因此可以最多有8个异步I/O请求处于等待状态。在检查操作之前的返回值之前，必须确认操作已经完成。当aio_error返回的值即非EINPROGRESS亦非-1时，表明操作完成。除了这些值之外，如果返回值是0以外的任何值，说明该操作失败了。一旦检查到这些情况，便可以安全地调用aio_return来获取I/O操作的返回值。只要还有事情要做，就可以提交异步I/O操作。当存在未使用的AIO控制块时，可以提交给一个异步读操作。读操作完成后，翻译缓冲区中的内容并将它提交给一个异步写请求。当所有AIO控制块都在使用中时，通过调用aio_suspend等待操作完成。
在打开要从中读取数据的文件之后，程序就清空了 aiocb 结构，然后分配一个数据缓冲区。并将对这个数据缓冲区的引用放到 aio_buf 中。然后，程序将 aio_nbytes 初始化成缓冲区的大小。并将aio_offset 设置成 0(该文件中的第一个偏移量)。程序将 aio_fildes 设置为从中读取数据的文件描述符。在设置这些域之后，就调用 aio_read 请求进行读操作。然后可以调用 aio_error 来确定 aio_read的状态。只要状态是 EINPROGRESS，就一直忙碌等待，直到状态发生变化为止。现在，请求可能成功，也可能失败。
下面的程序打开其命令行参数中命名的每个文件，并使用aio_read对生成的文件描述符的请求进行入队。 然后，程序循环，定期监视使用aio_error仍在进行的每个I /O操作。 每个I /O请求被设置为通过传递信号来提供通知。 所有I /O请求完成后，程序使用aio_return检索其状态。 SIGQUIT信号(通过键入control- \生成)导致程序使用aio_cancel请求取消每个未完成的请求。
输入文件(同步读取)将使用指定的传输大小复制到输出文件(异步)。 信号处理程序计算完成次数，但不是程序运行所必需的。 对aio_suspend函数的调用就足够了。
在创建自己的 aiocb 请求之后，我们使用 SIGEV_THREAD 请求了一个线程回调函数来作为通知方法。然后我们将指定特定的通知处理程序，并将要传输的上下文加载到处理程序中(在这种情况中，是个对 aiocb 请求自己的引用)。在这个处理程序中，我们简单地引用到达的 sigval 指针并使用 AIO 函数来验证请求已经完成。
注意，aio_suspend 的第二个参数是 cblist 中元素的个数，而不是 aiocb 引用的个数。cblist 中任何 NULL 元素都会被 aio_suspend 忽略。 如果为 aio_suspend 提供了超时，而超时情况的确发生了，那么它就会返回 -1，errno 中会包含 EAGAIN。
我们在 aio_completion_handler 函数中设置信号处理程序来捕获 SIGIO 信号。然后初始化 aio_sigevent 结构产生 SIGIO 信号来进行通知(这是通过 sigev_notify 中的 SIGEV_SIGNAL 定义来指定的)。当读操作完成时，信号处理程序就从该信号的 si_value 结构中提取出 aiocb，并检查错误状态和返回状态来确定 I/O 操作是否完成。
使用LIO_WRITE aio_lio_opcode调用aioc的aiocb文件，将数据写入一个文件，这个aiocb检查数据被有效地读取(忽略aio_lio_opcode)
打开文件,使用aio_write写入512个字节,然后使用aio_read 读取513字节并对读取的数据进行检查
创建一个无效的aio_filedes的aiocb 用这个aiocb调用aio_read 检查返回码和errno
将数据写入文件 使用aio_read读取文件 检查aio_read返回值
用一个NULL aio_buf填充aiocb   调用aio_read   检查aio_read返回值
由于系统资源限制，请求的AIO操作未入队到系统时，aio_read()将无法使用[EAGAIN]  打开文件，然后队列NUM_AIOCBS 512字节，aio_write一直等待直到返回EAGAIN 可能需要为系统调整NUM_AIOCBS
打开一个文件，填写一个aiocb为写作，调用aio_write usign这个aiocbm，填写一个新的aiocb，调用aio_return返回最后一个aiocb 如果aiocbp没有引用尚未检索其返回状态的操作，aio_return()可能会返回[EINVAL]失败
打开一个文件 填写aiocb进行写入操作 使用这个aiocb调用aio_write 调用aio_return获取aiocb状态(写入字节数)aio_return()将返回与aiocbp关联的状态
打开一个文件   填写aiocb进行写入操作   使用这个aiocb调用aio_write   调用aio_return获取aiocb状态(写入字节数)   再次调用aio_return，返回状态应为-1 aio_return()可能被调用一次以检索返回状态。
打开一个文件    填写aiocb进行写入操作   使用这个aiocb调用aio_write   调用aio_return获取aiocb状态(写入字节数)   重新使用aiocb写作 使用这个aiocb调用aio_write 调用aio_return获取aiocb状态(写入字节数)如果aiocbp用于提交另一个异步操作，那么aio_return可能会被成功地用于检索返回状态。
如果aiocbp用于提交另一个异步操作，那么aio_return可能会被成功地用于检索返回状态。    打开一个文件   填写aiocb进行写入操作   使用这个aiocb调用aio_write   调用aio_return获取aiocb状态(写入字节数)   再次调用aio_return，返回状态应为-1
执行aio_write()并检查结果与aio_error()                      aio_error()函数将返回与aiobcp参数相关联的错误状态(errno)。
将多个aio_write()进行入队到给定的fildes，然后检查是否至少是EINPROGRESS。 如果是，结果通过，否则则不能通过  操作尚未完成，将返回[EINPROGRESS]。
使用无效的aiocbp调用aio_error()如果aiocbp参数不引用尚未检索其返回状态的异步操作，则aio_error()将失败。
设置一个无效的aio_reqprio的aiocb   用这个aiocb调用aio_write   检查返回码和errno 如果aio_offset将无效，或者aio_reqprio不是有效的值，或者aio_nbytes是无效值,aio_write()将失败或操作的错误状态[EINVAL]
用一个NULL的aio_buf填充aiocb   调用aio_write   检查aio_write返回值  aio_write()函数将返回值-1并将errno设置为 如果操作未成功入队，则指示错误。
打开一个文件   对此文件执行aio_cancel（）   检查aio_cancel（）不是-1   aio_cancel（）适用于标准的fildes                            如果aiobcp为NULL，则所有未完成的可取消AIO对于fildes都将被取消。
我们将很多aio_write（）操作入队到一个文件描述符，然后我们尝试取消这个文件描述符的所有aio操作，我们检查每个操作的aio_error（）状态   如果aio_error（）为ECANCELED，而aio_return（）为-1，则会通过   如果aio_error（）为ECANCELED，而aio_return（）不为-1，则测试失败   否则测试未解决  错误状态应设置为[ECANCELED]，返回值为-1，成功取消AIO。
调用该函数挂起调用进程，直到一个或多个异步请求已完成。 阻塞等待异步读操作完成。
异步阻塞列表。
异步写入TXT文件中。
调用该函数执行异步写操作。当该函数返回成功时，说明该写请求以进行排队(成功0，失败-1)。其中aio_fildes字段指定其异步写操作被同步文件。
进行异步写操作，等待异步返回。
调用alarm、pause函数，进程可以指定休眠一段时间。其中alarm函数可以设置一个定时器（闹钟时间），在将来某个时刻该定时器会超时，产生SIGALRM信号。若忽略或不捕捉此信号，则默认调用alarm函数进程。进程休眠seconds时间。
调用函数sig_handler打印相关信息并使进程休眠8秒,之后进程再休眠8秒，打印出相关信息，并判断是否pause。
进程休眠2秒后，循环判断pause是否执行。
使用了setjmp、longjmp避免竞争。调用了函数sig_alrm，之后进行进程休眠。
调用atexit函数主要用来登记终止处理程序。atexit中参数是一个地址，调用此函数时无需向它传递任何参数，也无需期待它的返回值。
依次注册终止函数func3、func2、func1。
依次注册终止函数func1、func2、func3、func2、func2。
注册终止函数show1、show2。
注册终止函数exit1、exit2。
注册终止函数functionA。
执行挂起一段时间，sleep(1)就是休眠1秒,usleep单位则是微秒，usleep(1000000)则为休眠1000000微秒。
用sleep(time)函数来睡眠time秒；但是这个函数是可以被中断的，也就是说当进程在睡眠的过程中，如果被中断，那么当中断结束回来再执行该进程的时候，该进程会从sleep函数的下一条语句执行；这样的话就不会睡眠time秒了。 先调用sig_handler函数，之后执行sleep函数。
先调用sig_handler函数，之后循环判断当time大于0时，才执行sleep函数。
执行主函数打印，再执行挂起指定的时间a秒。打印相关信息。
判断是否为终端设备，若是则等待所有输出都被传递
判断是否为终端设备，若是则将输出挂起
判断是否为终端设备，若是则清空输入输出缓冲区
修改终端控制字符
使用屏蔽字标志取一个值和设置一个值
实现isatty，即判断一个设备是否为终端设备
实现标准输入
实现非标准输入
实现非同步式输入
设置波特率，注意每台机器都有输出和输入接受信息的速度 ，所以用cfsetispeed 和cfsetospeed来分别设置；
设置奇偶校验，数据，停止位
禁止终端中的中断字符（即CTRL+C），并且将文件结束的字符更改为CTRL+B
获取标准输入终端(STDIN)的属性并更改标准输入终端为raw模式(也可以使用更简便的调用－cfmakeraw()完成)，接收键盘输入、显示键值，直到接收到Ctrl-b输入
设置 stdin 的 PGID
打开文件目录，遍历文件目录，并输出目录的名字与相对开始目录偏移位置
获取当前时间，输出不同格式的时间
输出自1970年一月一号至今的过了多少小时
输出用户和系统的时间
记录数据库查询需要的时间
截断数字，去除小数
等待子进程，检查子进程的状态
创建打开临时文件，等待文件关闭或者进程退出再删除文件
设置文件访问和修改的时间
设置当前时间为文件的修改时间
设置文件大小资源限制与获取文件资源限制的大小
将字符写入标准输出及其错误判断
将字符写入文件及其错误判断
输出文件信息：读写权限及尺寸大小和链接
挂起进程特定时间
每个进程设置时间间隔
向打开的文件里写数据或二进制
判断文件属性
获取日志
返回一个临时文件文件名
创建一个临时二进制（类型wb+)文件
将文件长度截断长度为length的文件
获取指向控制终端名的指针
创建一个临时二进制（类型wb+)文件，
解析命令行选项
从命令行中选择选项
创建一个pty程序。当我们用pty来执行另一个程序时，该程序在一个它自己的会话中执行，并和一个伪终端连接。
客户端通过这段代码打印文件，打开文件，发送文件到打印机
用于测试服务器命令行选项
用于处理命令行参数
取得参数pid指定进程所属的组ID
创建一个孤儿进程组
用来取得目前进程所属的组ID.  此函数相当于调用getpgid(0)
如果socket已经连接，获取socket的对方地址
生成简易服务器
如果socket已经连接，获取socket的对方地址
显示子进程与父进程的进程组id
等待子进程然后检查它的状态
等待子进程在一个SIGCHLD信号量处理者上
从标准输入读命令行并执行
通过调用两次fork避免僵尸进程的出现
执行一个解释器文件
没有信号量处理的系统函数
运行该程序，判断强制锁是否支持
获取并返回目前进程的进程ID
假设count是临界资源，根据返回的进程ID和输出的count，判断父子进程是否同时访问临界资源
区分父子进程的进程PID，以及执行顺序
写日志例子，返回写日志进程的PID
获取并返回目前进程的父进程ID
fork()创建子进程，输出父进程PID，输出子进程PID
fork()创建子进程,若子进程id大于0，返回父子进程PID
通过getpid()获取当前进程的PID，然后以PID为参数，返回此进程的优先级
当蓝牙耳机配对成功后，会发送一个BONDING_STATE_CHANGE的消息，在BondStateMachine状态机里会对这个消息进行处理，调用setProfilePriorty(dev)函数对当前的耳机进行优先级的设置， 把以前的设置优先级顺序Hid、A2DP、Headset改为Headset、A2DP、Hid
该函数用来指定进程的优先级，先用 int oldpro = getpriority( PRIO_PROCESS, getpid() );获取当前id优先级，在用 setpriority( PRIO_PROCESS, getpid(), oldpro + increament )函数，在原来的优先级基础上改变当前进程的优先级
根据返回的线程优先级，判断线程执行顺序
首先加载Socket库，然后判断是否用了tcp协议，否则输出错误
服务器监听：服务器端处于等待连接的状态，实时监控网络状态。等待客户端发送请求并确认连接
接受两个参数，一个是监听服务器的 ip，一个是端口，然后把 sh shell 反弹到监听服务器上
使用公共协议名字来获取一个协议类型，产生一个你自己的服务器端
通过协议号读取协议数据库中（常见是读取/etc/protocols）的指定条目，并从条目中返回包含分解字段的原始结构。
取得协议编号0到4的协议数据
指定协议编号后，创建原始套接字
针对ECHO服务的TCP客户软件的实现
针对echo服务的并发的面向连接的服务器软件的实现
针对TIME服务的UDP客户软件的实现
针对TIME服务的UDP服务器端软件的实现
从协议数据库中（常见是读取/etc/protocols）读取所有条目，并从条目中返回包含分解字段的原始结构。
统计机器上已有的协议数目
获取取得root账号的识别码和根目录
获取指定用户名的用户登录信息
获取当前登录用户信息
显示所有用户信息
验证输入的用户密码
实现getpwnam
关联地址和套接字，绑定80端口 http的默认端口
关联地址和套接字，绑定8080端口 tomcat的默认端口
关联地址和套接字，监听21端口 ftp的默认端口
关联地址和套接字，监听443端口 https的默认端口
关联地址和套接字，监听3306端口 mysql的默认端口
动态申请内存空间和释放
创建线性表时申请内存空间
创建空栈时申请内存空间
创建二叉树时申请内存空间
根据用户需要动态申请内存空间
获取设备1的输入波特率
获取设备2的输入波特率
获取设备3的输入波特率
获取设备4的输入波特率
获取设备5的输入波特率
获取设备1的输出波特率
获取设备2的输出波特率
获取设备3的输出波特率
获取设备4的输出波特率
获取设备5的输出波特率
将工作目录更改至一个指定的目录，然后调用getcwd，并打印该工作目录
返回一个指向保存当前工作目录的绝对路径名的数组的指针
正常获取当前工作目录并打印
当缓冲区长度不足时无法获取到当前工作目录
用标准的系统函数getcwd实现的GNU C库函数gnu_getcwd
获取当前进程的有效用户ID和有效组ID并设置为有效用户ID和有效组ID，最后执行一段Python脚本程序
获取当前进程的有效组ID并设置为有效组ID，最后执行系统命令输出字符串提示
获取当前进程的有效用户ID和有效组ID并设置为有效用户ID和有效组ID，最后执行系统命令env
获取当前进程的有效组ID并设置为有效组ID，最后从标准输入中读取数据到缓冲区
获取并打印当前进程的用户ID、有效用户ID、实际组ID和有效组ID，然后杀死当前进程，重新设置相关ID后再次打印
打印当前进程的有效用户ID，重置其有效用户ID后打印新的有效用户ID
打印当前进程的有效用户ID，若出错则程序退出
设置当前进程的用户ID为有效用户ID
借助有效用户ID进行socket网络间通信
当使用root用户身份执行程序，其有效用户ID为0
打印输入关键字所对应的环境变量的值
打印用户属性文件和系统根用户的环境变量的值
根据用户名打印其对应的环境变量值
系统刷新环境变量后打印特定的环境变量的值
获取特定的名称“TEST”所对应的环境变量值，并打印输出
获取用户ID
获取主机用户信息
获取当前用户识别码
获取进程运行时的各种信息
从组文件(/etc/group)中循环调用取得所有组数据，并将getgrent()的读写地址指回组文件开头，读取组数据
从组文件(/etc/group)中循环调用取得所有组数据
从组文件(/etc/group)中循环调用取得所有组组成员
从组文件(/etc/group)中调用取得第一组组数据，并将其内容输出来
从组文件(/etc/group)中调用取得第一组组数据，并将其内容和组成员输出来
列出组名
获得组名
列出用户及组
取得gid＝3 的组数据
实现组ID到组名的转换
取得gid＝2 的组成员数据
实现ls命令
取得adm的组数据
将“manifest.txt”的群组变更为“officers”
根据用户名和组名获取各种信息
打印组中所有用户的名称
将调用进程的当前辅助组ID放入组数组中。若成功，返回ID的数量；若失败，返回-1
将调用进程的当前辅助组ID放入组数组中。若成功，打印成功，若失败，打印error。
返回主机名，若成功hostname为指向缓冲区的指针，sizeofhostname为缓冲区的长度；失败返回-1
由于gethostname在IPV6的情况下不是很好用，所以采用getaddrinfo可以更好的工作，本case是返回主机名的列表
返回登陆名等信息，并打印出来
获取辅助组ID，如果不能返回，则打印error
循环打印辅助组进程的名字和ID
获取主机名，成功打印成功，失败打印错误
获取主机名，并打印主机名字节数
获取主机名，并打印主机名和主机名字节数
获取登录名，并打印出来
获取登录名并打印用户所在组
获取所有的组ID并打印
获取所有的组名并打印
获取主机信息，如果成功，返回下一条信息的指针，如果失败，则返回NULL
获取主机信息，并打印下一条目信息
打印当前用户信息
getgroup() 用来取得目前用户所属的组代码. 参数size 为list() 所能容纳的gid_t 数目. 如果参数size 值为零, 此函数仅会返回用户所属的组数。
将一个地址转换为一个主机名和一个服务名。
通过地址来获取主机名，并判断了主机名的合法性。
获取特定的主机的相关信息。
获取本机的主机信息和网络信息。
获取特定主机信息，及其所有网卡的信息，并显示出错误信息。
用 socket 网络编程来实现服务端的 epoll 。模型
通过网络号和网络类型来获取网络名。
通过网络号和网络类型来获取网络别名。
通过网络号和网络类型来获取类型信息。
通过网络号和网络类型来获取网络号等信息。
通过网络号和网络类型来获取网络相关信息。
通过网络名来获取网络别名。
通过网络名来获取类型信息。
通过网络名来获取网络号等信息。
直接获取网络名。
直接获取网络别名。
直接获取网络类型信息。
直接获取网络号等信息。
直接获取网络相关信息。
函数thr_fn不需要参数，所以最后一个参数设为空指针。第二个参数我们也设为空指针，这样将生成默认属性的线程。当创建线程成功时，函数返回0，若不为0则说明创建线程失败，常见的错误返回代码为EAGAIN和EINVAL。前者表示系统限制创建新的线程，例如线程数目过多了；后者表示第二个参数代表的线程属性值非法。创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。
用于只是应用程序在线程tid终止时回收其存储空间
比较两个线程 ID是否相等
强制退出一个线程（非执行完毕退出），一般用于线程内部
创建线程
回收存储空间
比较两个线程 ID是否相等
强制退出某个线程
创建线程
回收存储空间
比较两个线程 ID是否相等
强制退出
创建一个线程
回收一个线程
比较两个线程 ID是否相等
强制退出一个线程（非执行完毕退出），一般用于线程内部
创建线程
回收线程存储空间
比较两个线程 ID是否相等
强制退出
设置一个被attr参数引用的有很多初始化属性对象内的时钟属性值
attr指定的值是一个无效引用会导致设置时钟属性失败
时钟id不是一个存在的时钟设置时钟属性值失败
时钟id对应的系统时钟会导致设置时钟属性失败
当函数不支持检查点重新启动时会导致设置属性值失败
设置attr条件属性对象内的pshared指定的属性的值
attr指定无效引用会导致设置进程共享属性值失败
指定的进程共享属性无效会导致设置进程共享属性值失败
指定的进程共享属性值为PTHREAD_PROCESS_SHARED
指定的进程共享属性值为PTHREAD_PROCESS_PRIVATE
多个线程在等待某一个条件变量，那么由调度策略决定解除顺序
该函数会打断所有的等待，然后对应的多个线程作出反应
线程被阻塞后，等待由cond指定的条件被触发
替代sleep而且不让整个进城休眠的方法
条件变量应该和互斥锁一起使用
销毁由cond参数指定的条件变量
条件变量应该和互斥锁一起使用
无法销毁一个正在被另一个线程引用的条件变量对象
无法销毁一个无效的cond引用
在一个条件变量上等待的所有线程被唤醒后才立即销毁该指定的条件变量
用于初始化条件变量
用于模拟Python线程安全队列集合的API和行为
实现c++线程池
用pthread进行流处理
用于任务延迟调度测试
用于解除线程的阻塞状态
使用多线程对多个文件进行wordcount
用于共享内存编程
实现具有多线程的服务器/客户端类型的网络应用程序。该程序读取客户端文件，通过TCP/IP将其传输到服务器端，并保存。每个程序都设计为在单独的线程中同时执行通信处理和文件处理。线程间通信通过独占控制的共享缓冲区实现。
实现多核游戏主循环，包含三个缓冲区，由N个线程并行定期更新，读写器锁定。
用于等待条件变量变为真，可以设置愿意等待的时间
用于线程同步
实现了一个间隔定时器
mac隐藏设备访问
实现一个任务队列
用于等待条件变量变为真
用于实现读写锁
用于计算Left-Truncatable Primes
实现具有POSIX多线程的应用程序，通过条件变量来信号工作完成，然后终止。
实现FIFO队列
创建全局进程再将其销毁最后打印线程状态
*主线程创建了线程thread1,线程thread1创建了thread2.两个线程分别将tsd作 * 为线程私有数据。从程序运行结果可以看出，两个线程tsd的修改互不干扰，可 * 以看出thread2先于thread1结束，线程在创建thread2后，睡眠5秒等待thread2 * 执行完毕。可以看出thread2对tsd的修改并没影响到thread1的tsd的取值.
创建五个线程并行读取一个文件
创建ThreadLocal对象并将两个线程传递进去在进行进一步的操作
创建两个线程连接后在输出个线程的详细信息
创建三个进程并再进程间传递信息
判断线程是否存活
子线程向主线程传递信号
以不同方式创建线程并相互传递信息
创建两个线程并将其中一个线程的地址传递给另一个线程用作起始地址
创建以及销毁互斥量并输出互斥量状态
主程序创建线程，线程计算数据，然后打印出结果。在创建线程前，创建输入数据。因为所有线程更改同一个结构体，所以我们需要一个互斥量。主线程需要等待所有线程完成，它等待这些线程中的一个，我们为线程赋予属性，允许主线程连接（join）其它被创建的线程。注意，当不再需要它们是要记得释放它们。
获取互斥锁的范围
主线程等待其他线程都完成工作后自己再向下执行
/*这是一段伪代码,看懂意思就成main里面不断判断线程,如果test_thd存在就删除,如果不存在,就创建.这里面创建线程的属性统一为缺省状态(PTHREAD_CANCEL_ENABLE).*/
线程资源共用
由系统来回收线程所占用资源在线程，创建时将其属性设为分离状态
创造分离线程
创建了一对无名的套接字描述符（只能在AF_UNIX域中使用），描述符存储于一个二元数组,eg. s[2] .这对套接字可以进行双工通信，每一个描述符既可以读也可以写。这个在同一个进程中也可以进行通信，向s[0]中写入，就可以从s[1]中读取（只能从s[1]中读取），也可以在s[1]中写入，然后从s[0]中读取；但是，若没有在0端写入，而从1端读取，则1端的读取操作会阻塞，即使在1端写入，也不能从1读取，仍然阻塞；反之亦然......
在父子进程之间各关闭了一个描述符，则在父进程写可从子进程读取，反之若子进程写，父进程同样可以读取；
closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket：
如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历
在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：
在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节 (异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据 和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：
如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响 程序的性能
打开阴影口令数据文件，访问阴影口令的接口。第一次调用时会取得第一项组数据，之后每调用一次就会返回下一项数据，直到已无任何数据时返回NULL。读取数据完毕后
打开阴影口令数据文件
打开阴影口令数据文件，并进行查询操作
要查看整个口令文件，POSIX.1接口则不能满足要求，需使用下列接口
getspent函数是访问阴影口令的接口，返回值是spwd的指针.并进行读取操作
为进程设置有效的用户ID
将进程设置用户ID为100
为进程设置有效的用户ID
为进程设置有效的用户ID为user
为进程设置有效的用户Id为root
设置文件流的缓冲区
判断是否能正确打开文件
程序把缓冲输出保存到 buff
程序将缓冲区分配给file文件
已知更好的大小时更改缓冲区大小的使用
是用来允许本进程访问一块共享内存的函数，与shmget（）函数共同使用
是用来允许本进程访问一块共享内存的函数，与shmget（）函数共同使用
是用来允许本进程访问一块共享内存的函数，与shmget（）函数共同使用
是用来允许本进程访问一块共享内存的函数，与shmget（）函数共同使用
是用来允许本进程访问一块共享内存的函数，与shmget（）函数共同使用
完成对共享内存的控制
完成对共享内存的控制
完成对共享内存的控制
完成对共享内存的控制
完成对共享内存的控制
与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存
与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存
与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存
与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存
与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存
得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符
得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符
得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符
得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符
得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符
进行不能对指定套接口进行写操作
进程不能对指定套接口进行读操作
进程不能对指定套接口进行读写操作
即使套接口s仍然通过文件描述符d打开，shutdown函数仍然立即将套接口彻底关闭。
成功则返回0，错误返回-1，错误码errno：EBADF表示sockfd不是一个有效描述符；ENOTCONN表示sockfd未连接；ENOTSOCK表示sockfd是一个文件描述符而不是socket描述符
信号名称和信号号之间的转换
信号名称和信号号之间的转换
信号名称和信号号之间的转换，输出转换后的字符串
信号名称和信号号之间的转换,输出错误
信号名称和信号号之间的转换
检查或修改与指定信号相关联的处理动作（可同时种操作）
检查或修改与指定信号相关联的处理动作（可同时种操作）
检查或修改与指定信号相关联的处理动作（可同时种操作）
检查或修改与指定信号相关联的处理动作（可同时种操作）
检查或修改与指定信号相关联的处理动作（可同时种操作）
用来将参数signum 代表的信号加入至参数set 信号集里
用来将参数signum 代表的信号加入至参数set 信号集里
用来将参数signum 代表的信号加入至参数set 信号集里
用来将参数signum 代表的信号加入至参数set 信号集里
用来将参数signum 代表的信号加入至参数set 信号集里
从信号集中删除一个信号，将参数signo代表的信号从参数set信号集里删除
从信号集中删除一个信号，将参数signo代表的信号从参数set信号集里删除
将参数set信号集初始化并清空，所有应用程序在使用信号集前，要对该信号集调用一次sigemptyset或sigfillset
将参数set信号集初始化并清空，所有应用程序在使用信号集前，要对该信号集调用一次sigemptyset或sigfillset
将参数set信号集初始化并清空，所有应用程序在使用信号集前，要对该信号集调用一次sigemptyset或sigfillset
用来将参数set信号集初始化， 然后把所有的信号加入到此信号集里所有应用程序在使用信号集前，要对该信号集调用一次sigemptyset或sigfillset；
用来测试参数signo代表的信号是否已加入至参数set信号集里用一位代表一个信号的方法实现信号集，sigismember用于测试一个指定位
用来测试参数signo代表的信号是否已加入至参数set信号集里用一位代表一个信号的方法实现信号集，sigismember用于测试一个指定位
用来测试参数signo代表的信号是否已加入至参数set信号集里用一位代表一个信号的方法实现信号集，sigismember用于测试一个指定位
用来测试参数signo代表的信号是否已加入至参数set信号集里用一位代表一个信号的方法实现信号集，sigismember用于测试一个指定位
sigsetjmp()会保存目前堆栈环境， 然后将目前的地址作一个记号， 而在程序其他地方调用siglongjmp()时 便会直接跳到这个记号位置，然后还原 堆栈，继续程序好执行。  返回0代表局促存好目前的堆栈环境，随时可供siglongjmp()调用， 若返回非0值则代表由siglongjmp()返回
sigsetjmp()会保存目前堆栈环境， 然后将目前的地址作一个记号， 而在程序其他地方调用siglongjmp()时 便会直接跳到这个记号位置，然后还原 堆栈，继续程序好执行。  返回0代表局促存好目前的堆栈环境，随时可供siglongjmp()调用， 若返回非0值则代表由siglongjmp()返回
sigsetjmp()会保存目前堆栈环境， 然后将目前的地址作一个记号， 而在程序其他地方调用siglongjmp()时 便会直接跳到这个记号位置，然后还原 堆栈，继续程序好执行。  返回0代表局促存好目前的堆栈环境，随时可供siglongjmp()调用， 若返回非0值则代表由siglongjmp()返回
sigsetjmp()会保存目前堆栈环境， 然后将目前的地址作一个记号， 而在程序其他地方调用siglongjmp()时 便会直接跳到这个记号位置，然后还原 堆栈，继续程序好执行。  返回0代表局促存好目前的堆栈环境，随时可供siglongjmp()调用， 若返回非0值则代表由siglongjmp()返回
sigsetjmp()会保存目前堆栈环境， 然后将目前的地址作一个记号， 而在程序其他地方调用siglongjmp()时 便会直接跳到这个记号位置，然后还原 堆栈，继续程序好执行。  返回0代表局促存好目前的堆栈环境，随时可供siglongjmp()调用， 若返回非0值则代表由siglongjmp()返回
信号函数
信号函数
信号函数
信号函数
信号函数
返回信号集
返回信号集
返回信号集
返回信号集
返回信号集
检测和更改进程的信号屏蔽字.
检测和更改进程的信号屏蔽字.
检测和更改进程的信号屏蔽字.
检测和更改进程的信号屏蔽字.
检测和更改进程的信号屏蔽字.
利用sigaction安装SIGINT信号
利用sigaction实现signal，实际上signal底层实现就是利用sigaction
验证sigaction.sa_mask效果
给自身发送int型数据
进程间传递数据
sigsetjmp()会保存目前堆栈环境，然后将目前的地址作一个记号，而在程序其他地方调用siglongjmp()时便会直接跳到这个记号位置，然后还原堆栈，继续程序的执行。 参数env为用来保存目前堆栈环境，一般声明为全局变量 参数savesigs若为非0则代表搁置的信号集合也会一块保存 当sigsetjmp()返回0时代表已经做好记号上，若返回非0则代表由siglongjmp（）跳转回来。
longjmp() 和 siglongjmp() 并不是异步信号安全函数。如果一个信号处理将正在更新数据结构的主函数打断，然后以非局部跳转(nonlocal goto)退出信号处理函数，那么主函数里的更新动作就没法完成，从而导致被操作的数据结构遭到破坏。解决这个问题的一个办法是使用 sigprocmask()  函数，可以在更新一些敏感数据时用它临时阻塞相应信号。
setjmp,longjmp一般应用
信号处理中，使用sigsetjmp, siglongjmp可以避免“自动加入“
信号处理中的应用，longjmp返回时，会把信号加入信号屏蔽字中
进程执行到sigsuspend时，sigsuspend并不会立刻返回，进程处于TASK_INTERRUPTIBLE状态并立刻放弃CPU，等待UNBLOCK（mask之外的）信号的唤醒。进程在接收到UNBLOCK（mask之外）信号后，调用处理函数，然后把现在的信号集还原为原来的，sigsuspend返回，进程恢复执行。
进程的信号掩码被设置成参数sigmask设置的值，然后将进程挂起，直到捕获到一个信号或者是出现一个信号终止掉程序。如果是捕获到一个信号并且信号处理函数返回，然后函数sigsuspend就会返回，并且进程的信号掩码被设置为其调用函数sigsuspend之前的数值。   注意到该函数并没有成功的返回情况，如果该函数返回到调用进程中，那么就总是返回-1，并且errno被设置为EINTR(表示被中断的系统调用)。
sigsuspend的另一个使用的例子是:等待一个信号处理函数设置一个全局变量。我们同事捕获中断信号以及终止信号，但是想要唤醒主线程只有是在终止信号被捕获到的时候才行。
信号的另一个例子是，展示信号如何用于同步父进程和子进程
如果不使用线程的话，我们可以实现的最好的方法是当信号出现的时候在信号处理函数中设置一个全局变量，比如说，当我们捕获到信号SIGINT以及SIGALRM并使用signal_intr函数来安装信号处理函数，那么该信号将能够中断任意被阻塞的慢速系统调用。信号很有可能出现在等待一个慢速设备输入的read函数调用过程中， 比如说，我们可以设置一个定时器来防止在一个输入中永远等待
sigwait() 提供了一种等待信号的到来，以串行的方式从信号队列中取出信号进行处理的机制。sigwait（）只等待函数参数中指定的信号集，即如果新产生的信号不在指定的信号集内，则 sigwait（）继续等待。
通过在主线程中阻塞一些信号，其它的线程会继承信号掩码，然后专门用一个线程使用sigwait函数来同步的处理信号，使其它的线程不受到信号的影响。
sigwait的含义就如同它的字面意思:等待某个信号的到来。如果调用该函数的线程没有等到它想等待的信号那么该线程就休眠。
通过在主线程中阻塞一些信号，其它的线程会继承信号掩码，然后专门用一个线程使用sigwait函数来同步的处理信号，使其它的线程不受到信号的影响。
线程控制-sigwait函数
执行挂起一段时间
执行挂起一段时间
执行挂起一段时间
执行挂起一段时间
执行挂起一段时间
最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出
最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出
最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出
最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出
最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出
每当收到一个带外数据时，就有一个与之关联的带外标记。这是发送进程发送带外字节时该字节在发送端普通数据流中的位置。在从套接字读入期间，接收进程通过调用sockatmark函数确定是否处于带外标记
每当收到一个带外数据时，就有一个与之关联的带外标记。这是发送进程发送带外字节时该字节在发送端普通数据流中的位置。在从套接字读入期间，接收进程通过调用sockatmark函数确定是否处于带外标记
每当收到一个带外数据时，就有一个与之关联的带外标记。这是发送进程发送带外字节时该字节在发送端普通数据流中的位置。在从套接字读入期间，接收进程通过调用sockatmark函数确定是否处于带外标记
每当收到一个带外数据时，就有一个与之关联的带外标记。这是发送进程发送带外字节时该字节在发送端普通数据流中的位置。在从套接字读入期间，接收进程通过调用sockatmark函数确定是否处于带外标记
每当收到一个带外数据时，就有一个与之关联的带外标记。这是发送进程发送带外字节时该字节在发送端普通数据流中的位置。在从套接字读入期间，接收进程通过调用sockatmark函数确定是否处于带外标记
函数返回一个整型的socket描述符，若出错，返回-1。
函数返回一个整型的socket描述符，若出错，返回-1。
函数返回一个整型的socket描述符，若出错，返回-1。
函数返回一个整型的socket描述符，若出错，返回-1。
函数返回一个整型的socket描述符，若出错，返回-1。
获取并设置读写锁属性对象的进程共享属性
多线程操作，多reader，单writer模型
将rwlock的进程共享属性设置为PTHREAD_PROCESS_SHARED
该函数用于销毁先前使用pthread_rwlock_init（）创建的读/写锁。
在涉及到多线程使用二叉树时，锁定二叉树的每个节点
用指针的方式销毁锁
一个简单的例程，系统休眠后获得了锁。 主线程等待他们完成。 但是在等待之前，主线程会打印线程实现的并发。
初始化一个读写锁
变量声明初始化一个读写锁
指针方式初始化一个读写锁
服务器线程之间共享数据
获取一个读出锁
这将创建一个正常的锁，获取读取锁，释放读取锁，然后再次释放读取锁定（过度释放）。
多线程编程demo。 想像一下，若每个线程都保证按顺序运行，哪个进程将会获得锁
std :: map在多线程程序中读/写和删除
读写者问题的读锁线程函数 限时获取读写锁的读锁
读写者问题的写锁线程函数 限时获取读写锁的写锁
生产者消费者问题中的消费者线程中 限时获取读写锁的读锁
生产者消费者问题中的生产者线程中 限时获取读写锁的写锁
实现多个读线程负责读缓冲区的不同区间的内 容并打印，一个写线程负责改变缓冲区的数据问题的限时读线程
实现多个读线程负责读缓冲区的不同区间的内 容并打印，一个写线程负责改变缓冲区的数据问题的限时写线程
以单线程来使用 pthread_rwlock_tryrdlock子例程
以多线程来使用 pthread_rwlock_tryrdlock子例程
非阻塞的下获取读写锁的读锁 #模拟读者进行数据读取
非阻塞下获取读写锁的写锁 #模拟写者写入数据
一个写者，多个读者。用读写锁进行协调工作中的读线程
一个写者，多个读者。用读写锁进 行协调工作中的写线程
实现读者写者问题的一种例子
实现读者写者问题的一种例子
pthread_rwlock_unlock可用来释放在 rwlock 引用的读写锁对象中持有的锁。
pthread_rwlock_unlock可用来释放在 rwlock 引用的读写锁对象中持有的锁。
pthread_rwlock_unlock可用来释放在 rwlock 引用的读写锁对象中持有的锁。
pthread_rwlock_unlock可用来释放在 rwlock 引用的读写锁对象中持有的锁。
pthread_rwlock_unlock可用来释放在 rwlock 引用的读写锁对象中持有的锁。
pthread_rwlock_unlock可用来释放在 rwlock 引用的读写锁对象中持有的锁。
会一直阻塞直到写锁可以被获取为止。
会一直阻塞直到写锁可以被获取为止。
会一直阻塞直到写锁可以被获取为止。
会一直阻塞直到写锁可以被获取为止。
返回被调用的线程的线程id
返回被调用的线程的线程id
返回被调用的线程的线程id
返回被调用的线程的线程id
函数用来设置当前线程的“可取消性”状态，并且将先前的状态返回到oldstate引用中。
函数用来设置当前线程的“可取消性”状态，并且将先前的状态返回到oldstate引用中。
初始化一个自旋锁对象。
初始化自旋锁对象，然后加锁并释放。
多线程下的原子操作。
使用两个线程对一个对象的计数。
自旋锁与互斥锁在两个线程下小临界区的性能对比。
多线程中于自旋锁下的计数。
自旋锁与互斥锁在两个线程下大临界区的性能对比。
一个线程中于自旋锁下的计数。
尝试获取一个非锁定的自旋锁。
简单实现pthread_spin_lock函数
尝试获取指定的自旋锁。
简单实现pthread_spin_lock函数
尝试获取指定的自旋锁。
使用两个线程对一个对象的计数。
自旋锁与互斥锁在两个线程下小临界区的性能对比。
自旋锁与互斥锁在两个线程下大临界区的性能对比。
一个线程中于自旋锁下的计数。
多线程中于自旋锁下的计数。
用来设置当前线程的“可取消类型”，并且将先前的类型返回到oldtype引用中
设置立即取消
设置立即取消
为指定线程特定数据键设置线程特定绑定
将 pointer 的值 (不是锁指的内容) 与key 相关联
为指定线程特定数据键设置线程特定绑定
为指定线程特定数据键设置线程特定绑定
设置每个线程自己的私有数据
屏蔽某个线程对某些信号的响应处理，仅留下需要处理该信号的线程来处理指定的信号
当SIG_BLOCK时，线挰收到newmask和oldmask信号时，忽略它们
定义线程的信号掩码
在主调线程里控制信号掩码
屏蔽某个线程对某些信号的响应处理，仅留下需要处理该信号的线程来处理指定的信号
销毁指定的自旋锁并释放所有相关联的资源
销毁指定的自旋锁并释放所有相关联的资源
返回前台进程组的进程组ID，需要有一种方法来通知内核哪一个进程组是前台进程组，这样，终端设备驱动程序就能了解将终端输入和终端产生的信号送到何处。
在tcsetpgrp之前需要将原来的控制全台进程组ID保存下来，程序结束前重新设置回该进程组ID。
如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid。
函数tcgetpgrp返回和在filedes上打开的终端相关联的前台进程组的进程组ID。
进程可以调用tcsetpgrp来设置前台进程组ID给pgrpid。pgrpid的值必须是相同会话里的一个进程组的进程组ID，filedes必须引用会话的控制终端。
需要管理控制终端的应用程序可以调用tcgetsid函数识别出控制终端的会话首进程的会话ID
给出控制TTY的文件描述符，应用程序就能获得会话首进程的进程组ID。
检测会话是否存在
函数tcgetpgrp返回前台进程组的进程组ID，该进程组与filedes上打开的终端相关联。
返回前台进程组的进程组ID，该进程组与filedes上打开的终端相关联。
tcsendbreak() 传送连续的 0 值比特流，持续一段时间，如果终端使用异步串行数据传输的话。如果 duration 是 0，它至少传输 0.25 秒，不会超过 0.5 秒。如果 duration 非零，它发送的时间长度由实现定义。
tcsendbreak()函数在一个指定的时间区间内发送连续的0二进位流。若duration参数为0，则此种发送延续0.25-0.5秒之间。POSIX.1说明若duration非0，则发送时间依赖于实现。
传送连续的 0 值比特流，持续一段时间，如果终端使用异步串行数据传输的话。如果 duration 是 0，它至少传输 0.25 秒，不会超过 0.5 秒
传送连续的 0 值比特流，持续一段时间，如果终端使用异步串行数据传输的话。如果 duration 是 0，它至少传输 0.25 秒，不会超过 0.5 秒
设置指定终端的属性。可选动作项指定终端属性何时更改
tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用
设置指定终端的属性。可选动作项指定终端属性何时更改
设置指定终端的属性。可选动作项指定终端属性何时更改
设置指定终端的属性。可选动作项指定终端属性何时更改
打开一个文件，写入字符，并关闭
打开文件并关闭
创建子进程，父进程和子进程各自打印自己的进程ID
获取系统文件名字长度限制
打开文件写入字符
获取文件名，打开目标文件并读取输出
读出磁盘文件datafile.txt中的内容，将它们显示在屏幕上
只读打开文件并关闭文件
创建子进程，子进程打印自己的进程ID
打开文件，向文件中写入字符串
输出数字150
输出浮点数1.55
输出字符“str"
创建子进程，父进程打印自己的进程ID
输出换行
fwide函数用于设置流的定向。对于ASCII字符集，一个字符用一个字节表示，对于国际字符集，一个字符可用多个字节表示。而流的定向决定了所读写的字符是单字符还是多字符。当一个流最初被创建时，并没有定向。fwide的作用就是设置它的定向。
向文件写入一个数据块，返回实际写入的数据块数目。
根据返回的非零值返回指向对应的出错信息字符串的指针，error为getaddrinfo函数出错时返回非零值。
处理名字到地址以及服务到端口这两种转换，其中（1）hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串) （2）service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等 （3）hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：指定的服务既可支持TCP也可支持UDP，所以调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。 （4）result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。
把打开的文件清空，重新写入新的需求，使用ftruncate()函数操作，使用lseek()对文件指针的偏移量操作使其从头写入
使用文件和记录锁来保证只运 行一个守护进程的一个副本。 守护进程的每个副本都将试图 创建一个文件，并将其进程ID 写到该文件中。这使管理人员 易于标识该进程。如果该文件 已经加了锁，那么lockfile 函数将失败，errno设置为EACCES或EAGAIN。代码函数返回1，表明该守护进程已在运行。否则将文件长度截断为0，将进程ID写入该文件，函数返回0.
线程之间共享同一个FILE * 的情况，这种情况互斥是没问题的。一共100个进程,进行对同一个文件进行加以操作，因为有锁存在，所以最后的结果为100。
程序使用带O_TRUNC选项的open函数将文件长度截断为0，但并不更改其访问时间及修改时间。为了做到这一点，首先用stat函数得到这些时间，然后截断文件，最后再用futimens函数重置这两个时间
该程序首先打开两个文件，然 后调用fstat得到输入文件长 度。在为输入文件调用mmap 和设置输出文件长度时都需使 用输入文件长度。可以调用 ftruncate设置输出文件的长 度。如果不设置输出文件的长 度，则对输出文件调用mmap也 可以，但是对相关存储区的第 一次引用会产生SIGBUD信号。 然后对每个文件调用mmap，将 文件映射到内存，最后调用 memcpy将输入缓冲区的内容复 制到输出缓冲区。为了限制使 用内存的量，每次我们最多复制 1GB的数据（如果系统没有足够 的内存，可能无法把一个很大的 文件中的所有内容都映射到内存 中）。在映射文件中的后一部分 数据之前，我们需要删除前一部 分数据的映射
首先创建文件，接着对文件进行 截断的例子
打开将要拷贝的文件;获取要拷 贝文件的属性,从属性中获取文件的长度;如果文件长度为0，直接创建一个文件就ok。然后将待拷贝文件的内容映射到内存，映射建立后关闭文件，只要映射建立，关闭文件映射关系依然存在。新建文件，用来存放拷贝文件的内容。设置新建文件的长度，将新建文件和内存中的一段空间建立映射 ，将要拷贝的文件的内容的映射空间，存放到新创建文件的映射文件的存储空间，将内存中的数据同步到文件即磁盘，结束文件和内存之间的映射。
创建内存共享区对象，设置共享 内存区对象大小，创建信号量
Pthreads推荐总是在输出流之前 锁住输入流,考虑一致的锁层次， 先解锁输出流后解锁输入流,
Pthreads增加了新函数来代替旧 的高效宏，这些函数本质上与传 统的宏实现一样，并且不执行任 何锁操作，但可以和文件锁一起 使用，用于满足Pthreads要求的 锁住stdio流数据来防止代码对 stdio缓冲区的偶然破坏。
使用open的O_TRUNC截断文件长 度到0,但是不改变他们的access  time或者modification time. 为了达到这一目的，我们先用 stat获取时间，然后截断文件， 最后使用futimens来重置 (reset)时间
使用带O_TRUNC选项的open函数 讲文件长度截断为0，但并不更 改其访问时间和修改时间
获取当前时间，然后修改文件 时间
open函数讲文件长度截断为0， 但并不更改其访问时间和修改时 间
先确定命令行参数合法性,获取 文件截断前数据,用open截短文 件,设置文件时间与截断前一致
fseeko移动指针获取文件大小
通过off_t定位文件位置，然后进行读写
将偏移移动到绝对位置并放置一个字符来扩充文件
单线程测试fseeko的有效性
通过不同参数设置测试fseeko函数的有效性
结合fseeko创建流读取管道
将文件指针定位在pos指定的位置上。该函数的功能与前面提到的fgetpos相反，是将文件指针fp按照pos指定的位置在文件中定位。pos值以内部格式存储,仅由fgetpos和fsetpos使用。
应用fsetpos函数定位文件指针
应用fsetpos函数定位文件指针
读取文件内容，保存文件位置
获取文件位置
fsetpos应用示例
获得已在描述符fd上打开文件的有关信息，该函数与 stat() 函数相似，不同的是，它是作用于已打开的文件指针而不是文件名。
调用fstat()并在返回的fstat结构中显示所选字段。
调用fstat()并在返回的文件大小。
打开文件并获取文件信息,由文件描述词取得文件状态
获取有关目录中当前文件的信息
获取文件信息，失败时输出相关信息
为一个相对于当前打开目录（由fd参数指向）的路径名返回文件统计信息。
打开一个文件，然后写入一串字符，然后把缓冲区写入磁盘后，关闭文件
打开一个文件，返回文件的指针，关闭文件
把文件打开为一个流，判断是否到文件结尾，如果到文件尾则关闭文件
使用命令行输入的参数创建一个IPC对象的外部名
将标准输入复制到标准输出
将标准输入复制到标准输出
读取数据并将它显示出来
释放指针ps所指向的堆内存
释放一个或多个addrinfo链表结构。
用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。
用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。
用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。
根据数据格式(format)从输入流(fp)中写入数据
根据数据格式(format)从输入流(fp)中写入数据
设置文件指针fp的位置，定位一个二进制文件。
设置文件指针fp的位置，定位一个二进制文件。
设置文件指针fp的位置，定位一个二进制文件。
释放一个或多个addrinfo链表结构。
用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。
用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。
用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。
根据数据格式(format)从输入流(fp)中写入数据
根据数据格式(format)从输入流(fp)中写入数据
设置文件指针fp的位置，定位一个二进制文件。
设置文件指针fp的位置，定位一个二进制文件。
设置文件指针fp的位置，定位一个二进制文件。
允许程序监控多个文件描述符，等待一个或多个文件描述符为某种I/O操作做好准备（例如输入）
与psignal()函数类似，但打印的信息是用pinfo结构描述的
在stderr上显示一条消息，该消息包括字符串、冒号、空格、描述信号数字sig的字符串以及结尾的换行符
将在称为fork()的线程的上下文中声明fork()之前和之后调用的fork句柄
以分离状态创建线程
于获取关于thread 的各种信息并且列举出来
pthread_create (&thread, NULL, &thread_function, NULL)中，参数2没有设置线程结束后自动detach，并且没有使用pthread_join或pthread_detach释放执行结束后线程的空间，所以会导致pthread_create后的僵死线程没有释放，内存持续增长。Getdetach 可用于查看并判断detach state.
获取线程的堆栈地址和大小
等待子进程并检查子进程的状态
移去对一个文件的链接
等同于fscanf，可用于从数组中读取数据
获取当前时间
获取当前stack的大小，如果错误则显示
初始化一个线程属性，初始化错误则提示
将线程设置为分离状态
提供对栈指针溢出的保护。默认为系统页大小，如果设置为0表示没有保护区，大于0表示会为每个使用attr创建的线程提供大小至少为guardsize字节的溢出保护区。
将attr引用的线程属性对象的堆栈地址和堆栈大小属性分别设置为stackaddr和stacksize中指定的值。
将attr引用的线程属性对象的堆栈大小属性设置为stacksize中指定的值。
函数tcgetpgrp（）返回与fd关联的终端上的前台进程组的进程组ID，该进程组必须是调用进程的控制终端。
以方式"wb+"创建一个临时文件，并返回该流的指针，该文件在被关闭或程序正常结束时被自动删除
None
None
None
在释放资源时，由于线程的注册是按栈的顺序进行注册，在释放资源时也按对栈结构的操作进行释放。先压入清理函数，然后再按照出栈的方法取出清理函数。
创建进程，在拥有一定数量的进程后取消。
实现多线程同步操作
为用户设置一个权限的补码
是以wb+形式创建一个临时二进制文件
通过文件描述符打开文件
通过文件描述符打开文件
通过文件描述符打开文件
通过文件描述符打开文件
使用BSD样式函数来监听套接字，接受新连接的简化服务器
select模型服务器
简化的服务器
制定测试Socket的描述符的可读性
简化服务器，可侦听套接字和接受新的连接
select模型服务器
简化的服务器
测试单个文件描述符的可读性
搜索一个给定的目录，查找名称不是以点开始且大小大于1 MiB的文件。
从终端读取数据，再写回终端
非阻塞读终端和等待超时
回收子进程，并打印子进程id
父进程等待子进程苏醒才回收
父进程利用工作的简短间歇察看子进程的是否退出，如退出就收集它
将文件长度截短为0，但并不更新其访问时间和修改时间
清空文件描述符集readset，再将readset中对应于文件描述符5和33的相应位被置为1
首先清空fd_set集合所有元素，将stdout加进集合中，测试stdout是否在集合中，从位向量中清除stdout，再次测试stdout是否在集合中。
检测文件描述符为fd的文件的可读性
测试Socket的描述字的可读可写性
重写str_cli函数，使得客户不会阻塞于fgets调用
清空文件描述符 readset
清空文件描述符，设置文件描述符包含stdout
测试Socket的描述字的可读可写性
重写str_cli函数，使得客户不会阻塞于fgets调用
初始化文件描述符集合，设置文件描述符，检测是否在集合中，清空文件描述符集合，再次检测是否在集合中
检测文件流上的文件结束符
检测打开文件是否发生错误
逐行打印文件
用fget按行读取文件
读取文件，检测打开是否错误。写入新文件
用fget按行读取文件
用ferror函数检查读取文件是否发生错误
以写入模式读取一个文件(用 ferror检测错误并且返回)
发出dir命令，列出目录下所有文件
C语言调用DOS命令实现定时关机
fexecve()用来执行参数fd文件描述符指示的文件, 第二个参数系利用数组指针来传递给执行文件, 最后一个参数则为传递给执行文件的新环境变量数组.
执行ls文件，并与system()和popen()命令的用法做出对比
用open命令打开用户输入的文件路径对应的程序文件，并用fexecve命令执行程序
执行fd文件描述符指示的helloworld程序
执行ls程序，执行失败则直接返回-1，失败原因存于errno中
在读操作之前，用fflush操作将该流所有未写的数据都被传送至内核
先往文件缓冲区写入数据，再清空文件缓冲区
清空标准输入缓冲区，标准输入缓冲区即是用来暂存从键盘输入的内容的缓冲区
在使用get_s函数获得输入之前，用fflush函数清空标准输入缓冲区
fflush()会强迫将缓冲区内的数据写回参数stream指定的文件中. 如果参数stream 为NULL,fflush()会将所有打开的文件数据更新
fgetc()从参数fp所指的文件exist中读取一个字符，并把它作为一个字符返回。
该程序逐字符读取一个名为myfile.txt的现有文件，并使用变量n来计算该文件包含多少美元字符（$）。
读取crt_fgetc.txt文件前80个字符到buffer数组，并输出该数组
逐个读取test.txt文件中的字符并输出，判断读取是否到达文件末尾或是遇到I\O错误
打开文本文件test.txt，使用getc从文件流中逐个读取字符，直到读完并用putc()函数将字符数组写入文件
以a+方式打开文件file.txt，获取文件位置指示器存入pos1指针指向的对象，调用fsetpos函数获得该值，将流重新定位至该位置并写入
打开文本文件crt_fgetpos.txt读取一段字符，记录当前位置，再继续由当前位置向前读取一段字符，接着恢复记录的位置，再继续读取一段字符
该示例打开myfile.txt，然后读取第一个字符，然后读取相同的第二个字符3次。
程序打开一个文件test.txt，并把字符串"This is a test"写入文件，再用fgetpos函数取得指针位置并存入&pos所指向的对象，再用fseek函数重设文件指针的位置，让fp的值为3，即指向文件中第4个字节。再次取得指针位置并存入&pos所指向的对象。
使用 fgetpos() 函数获取文件的初始位置，接着向文件写入 Hello, World!，然后使用 fsetpos() 函数来重置写指针到文件的开头，重写文件.
从文件结构体指针stream中读取数据，每次读取一行
读取一份文件并打印出来
读取文件并写入另一文件
读取文件并计算文件有效字数
读取文件并计算文件所有字数
读取文件并计算指定字符在文件中的出现个数
读取文件并计算指定单词在文件中的出现个数
读取文件并计算各个字符出现的个数
取得参数stream指定的文件流所使用的文件描述符
获取文件描述符并且关闭
获取文件描述符并且进行复制
从标准输出到文件的重定向，经过dup2后进程A的任何目标为STDOUT_FILENO的I/O操作如printf等，其数据都将流入fd3所对应的文件中
通过文件描述符以及write和read方法对文件进行读写
程序先前用fopen打开了一个文件，然后对其进行锁定操作
以线程安全的方式管理FILE对象的方法
打开文件，输入一个整数，然后上一把写锁（LOCK＿EX），再输入一个整数将解锁（LOCK＿UN）
打开一个内存流，可以读取或写入由buf指定的缓冲区
使用fmemopen（）打开输入缓冲区，open_memstream（）打开动态大小的输出缓冲区。 该程序扫描其输入字符串（取自程序的第一个命令行参数）读取整数，并将这些整数的平方写入输出缓冲区
把一段内存映射成一个文件来操作
内存流写入
将两个领域、类型、协议相同的套接字连接在一起。
向标准输出输出格式化的字符串
读取指定格式的字符串，并存入后续参数指向的内存。
返回字符串path指定路径文件的具体信息，结果存至buf
介绍 该方法利用文件名获取文件信息并将其写入到指向的buf参数的地址。 参数 Path参数指向一个文件名，其读写执行权限不做要求。 Buf参数为将其写入的地址。(注意，存储空间要提前分配) 返回值 成功为0，失败为-1，并让errno指向error.
介绍 将信号名映射为信号编号。 参数 Str参数为信号地址 Signop参数为信号编号地址 返回值 成功为0，失败为-1，注意，失败时并不设置errono
介绍 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。 参数 errnum -- 错误号，通常是 errno。 返回值 该函数返回一个指向错误字符串的指针，该错误字符串描述了错误 errnum。
介绍 根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。 参数 str -- 这是指向目标数组的指针，用来复制产生的 C 字符串。 maxsize -- 这是被复制到 str 的最大字符数。 format -- 这是 C 字符串，包含了普通字符和特殊格式说明符的任何组合。这些格式说明符由函数替换为表示 tm 中所指定时间的相对应值。格式说明符是： 时间的相对应值。格式说明符是： 说明符 替换为 实例 %a 缩写的星期几名称  Sun %A 完整的星期几名称  Sunday %b 缩写的月份名称  Mar %B 完整的月份名称  March %c 日期和时间表示法  Sun Aug 19 02:56:02 2012 %d 一月中的第几天（01-31） 19 %H 24 小时格式的小时（00-23） 14 %I 12 小时格式的小时（01-12） 05 %j 一年中的第几天（001-366） 231 %m 十进制数表示的月份（01-12） 08 %M 分（00-59） 55 %p AM 或 PM 名称 PM %S 秒（00-61） 02 %U 一年中的第几周，以第一个星期日作为第一周的第一天（00-53） 33 %w 十进制数表示的星期几，星期日表示为 0（0-6） 4 %W 一年中的第几周，以第一个星期一作为第一周的第一天（00-53） 34 %x 日期表示法 08/19/12 %X 时间表示法 02:50:06 %y 年份，最后两个数字（00-99） 01 %Y 年份 2012 %Z 时区的名称或缩写 CDT %% 一个 % 符号 % timeptr -- 这是指向 tm 结构的指针，该结构包含了一个呗分解为以下各部分的日历时间： struct tm {    int tm_sec;         /* 秒，范围从 0 到 59                */    int tm_min;         /* 分，范围从 0 到 59                */    int tm_hour;        /* 小时，范围从 0 到 23                */    int tm_mday;        /* 一月中的第几天，范围从 1 到 31                    */    int tm_mon;         /* 月份，范围从 0 到 11                */    int tm_year;        /* 自 1900 起的年数                */    int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */    int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */    int tm_isdst;       /* 夏令时                        */     }; 返回值 如果产生的 C 字符串小于 size 个字符（包括空结束字符），则会返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。
介绍： 根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中，同时允许调用者将区域指定为参数，除此之外与strftime是相同的。  参数： str: 这是指向目标数组的指针，用来复制产生的 C 字符串。 maxsize: 这是被复制到 str 的最大字符数。 format : 这是 C 字符串，包含了普通字符和特殊格式说明符的任何组合。这些格式说明符由函数替换为表示 tm 中所指定时间的相对应值。 timeptr :这是指向 tm 结构的指针，该结构包含了一个被分解为以下各部分的日历时间：  struct tm {    int tm_sec;         /* 秒，范围从 0 到 59                */    int tm_min;         /* 分，范围从 0 到 59                */    int tm_hour;        /* 小时，范围从 0 到 23                */    int tm_mday;   /* 一月中的第几天，范围从 1 到 31                    */    int tm_mon;         /* 月份，范围从 0 到 11                */    int tm_year;        /* 自 1900 起的年数                */    int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */    int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */    int tm_isdst;       /* 夏令时                        */     }; locale：是由newlocale（）或LC_GLOBAL_LOCALE返回的locale_t，或当前使用uselocale（）设置的线程区域设置为0。  返回值： 如果产生的 C 字符串小于 size 个字符（包括空结束字符），则会返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。
介绍： 按照特定时间格式将字符串转换为时间类型。  参数： buf：一个包含时间格式的buffer。 format：转换的格式规范 tmptr：指向所转换的时间  返回值： 调用成功返回 *buf最后位置，失败返回空指针。 介绍： 按照特定时间格式将字符串转换为时间类型。  参数： buf：一个包含时间格式的buffer。 format：转换的格式规范 tmptr：指向所转换的时间  返回值： 调用成功返回 *buf最后位置，失败返回空指针。 介绍： 按照特定时间格式将字符串转换为时间类型。  参数： buf：一个包含时间格式的buffer。 format：转换的格式规范 tmptr：指向所转换的时间  返回值： 调用成功返回 *buf最后位置，失败返回空指针。
介绍： 给出一个信号编号，strsignal将返回说明该信号的字符串。应用程序可以用该字符串打印关于接收到信号的出错消息。  参数： signo：一个信号号码  返回值： 指向描述该信号的字符串的指针
介绍： 函数创建了一个指向actualpath的新目录项sympath。在创建此符号链接时，并不要求actualpath已经存在。并且，actualpath和sympath并不需要位于同一文件系统中。  参数： actualpath:实际路径 sympath：符号链接地址  返回值： 若成功，返回0；若出错，返回-1,错误原因存于errno.
介绍： 函数创建了一个指向actualpath的新目录项sympath。在创建此符号链接时，并不要求actualpath已经存在。并且，actualpath和sympath并不需要位于同一文件系统中。但sympath参数根据相对于打开文件描述符引用的目录（由fd参数指定）进行计算。  参数： Actualpath：实际路径 fd：根据相对于打开文件描述符引用的目录 sympath：符号链接地址  返回值： 若成功，返回0；若出错，返回-1,错误原因存于errno.
这个函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。
使用pthread_once来保护对象申请，来保证“单例”，及时在多线程的情况下，这是muduo库作者的思路。
这个函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。
程序执行后，线程中指定函数部分在两个子线程中出现，不过只执行一次。
销毁读写锁属性对象。
销毁一个rwlock属性对象。 对象不可再使用。
销毁一个读写锁定属性对象attr。
销毁一个读写锁定属性对象。 后续使用对象的效果是未定义的，直到对象被另一次调用pthread_rwlockattr_init重新初始化为止。
用于在接收到某个信号之前，临时用sigmask替换进程的信号掩码，并暂停进程执行，直到收到信号为止.sigsuspend返回后将恢复调用之前的的信号掩码。信号处理函数完成后，进程将继续执行。
用pthread_rwlockattr_init（）初始化一个pthread_rwlockattr_t对象，调用pthread_rwlockattr_getpshared（）来检查进程是否共享。   *属性设置为默认值PTHREAD_PROCESS_PRIVATE。
确定是否可以在进程之间共享使用'attr'创建的rwlock。
从attr引用的初始化属性对象中获取进程共享属性的值。
返回PSHARED中ATTR的进程共享属性的当前设置。
用pthread_rwlockattr_init（）初始化pthread_rwlockattr_t对象。
使用默认值初始化属性对象ATTR。
使用定义的所有属性的默认值初始化读写锁属性对象attr。
使用由attr引用的属性初始化由rwlock引用的读写锁。
如果已经创建了使用默认值初始化属性对象ATTR则返回-1。
当 pthread_mutex_lock() 返回时，该互斥锁已被锁定。
释放 mutex 引用的互斥锁对象。
如果 mutex 所引用的互斥对象当前被任何线程（包括当前线程）锁定，则将立即返回该调用。 否则，该互斥锁将处于锁定状态，调用线程是其属主。
可以销毁与 mp 所指向的互斥锁相关联的任何状态。 请注意，没有释放用来存储互斥锁的空间。
函数使用互斥锁确保对共享变量进行原子更新
函数使用互斥锁保证以原子方式读取 64 位数量 count。
把参数pid 指定的信号传送给一个或一组进程
用于在接收到某个信号之前，临时用sigmask替换进程的信号掩码，并暂停进程执行，直到收到信号为止.sigsuspend返回后将恢复调用之前的的信号掩码。信号处理函数完成后，进程将继续执行。
获取和改变调用进程的信号掩码
返回被阻塞而为调用进程待定的信号, 信号集通过set参数返回
为指定的信号安装一个新的信号处理函数
将参数set信号集初始化并清空
将参数signo代表的信号从参数set信号集里删除
将信号加入到信号集中
检查和改变信号的处理方式
用来向自身进程发送信号
创建管道
返回调度策略静态优先值的最大值
返回调度策略静态优先值的最小值
获取进程的调度参数
